"""Authentication routes."""
from hashlib import sha512
from secrets import token_urlsafe

from fastapi import APIRouter, Body, Depends, Query, Request
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy import select

from intape.core.config import (
    RESERVED_USERNAME_SPACES,
    RESERVED_USERNAMES,
    Config,
)
from intape.core.exceptions import (
    EmailTakenException,
    InvalidCredentialsException,
    NotImplementedException,
    ReservedUsernameException,
    UsernameTakenException,
)
from intape.dependencies import get_config, get_current_user
from intape.models import UserModel, UserTokenModel
from intape.schemas import (
    ChangeUserPasswordSchema,
    CreateUserSchema,
    LoginUserSchema,
    PublicUserSchema,
    UserAuthSchema,
)
from intape.utils.passwords import get_password_hash, verify_password

router = APIRouter(tags=["auth"], prefix="/auth")


@router.get("/check_username", response_model=bool)
async def check_username(
    request: Request, username: str = Query(regex=r"^[a-zA-Z0-9_]+$", max_length=16, min_length=3)
) -> bool:
    """Check username.

    Used to check if a username is available.

    Returns:
    - bool: `true` if username is available, `false` if username is taken.
    """
    query = await request.state.db.execute(select(UserModel).filter_by(name=username))
    user: UserModel | None = query.scalars().first()
    if user is None:
        return True
    return False


@router.get("/get_salt", response_model=str)
async def get_salt(
    request: Request, username: str = Query(regex=r"^[a-zA-Z0-9_]+$", max_length=16, min_length=3)
) -> str:
    """Get salt.

    Used to get the salt for a user.

    Returns:
    - str: Salt for the user. If the user does not exist, returns an random string.
    """
    query = await request.state.db.execute(select(UserModel).filter_by(name=username))
    user: UserModel | None = query.scalars().first()
    if user is None:
        return token_urlsafe(32)

    if not user.client_salt:
        return ""

    return user.client_salt


@router.post("/register", response_model=UserAuthSchema)
async def register(*, request: Request, config: Config = Depends(get_config), user: CreateUserSchema) -> UserAuthSchema:
    """Register endpoint.

    Used to register a new user.

    Password is hashed with SHA512 function with the `client_salt`
    before sent to the server. This is done to prevent the server from
    knowing the password and stealing via MitM attacks. The salt is
    generated by the client or requested from the server at `/get_salt`
    endpoint.

    Raises:
    - UsernameTakenException: If the username is taken.
    - EmailTakenException: If the email is taken.
    - ReservedUsernameException: If the username is reserved.

    Returns:
    - UserAuthSchema: User authentication schema with JWT tokens.
    """
    # TODO: Add captcha
    # TODO: Add email verification

    # Disallow reserved usernames specified in `intape.core.config`
    if user.name in RESERVED_USERNAMES:
        raise ReservedUsernameException(detail="Username is reserved.")
    if user.name.startswith(RESERVED_USERNAME_SPACES):
        raise ReservedUsernameException(detail="Prefix of username is reserved.")

    db = request.state.db

    # Check if username is taken
    query = await db.execute(select(UserModel).filter_by(name=user.name))
    if query.scalars().first() is not None:
        raise UsernameTakenException()

    # Check if email is taken
    query = await db.execute(select(UserModel).filter_by(email=user.email))
    if query.scalars().first() is not None:
        raise EmailTakenException()

    # Hash password
    hashed_password = get_password_hash(user.password)

    # Create user
    db_user = UserModel(name=user.name, email=user.email, password=hashed_password, client_salt=user.client_salt)
    db.add(db_user)
    await db.commit()

    # Return auth info
    refresh_token_model = await UserTokenModel.create_obj(db, db_user.id)
    refresh_token = refresh_token_model.issue_refresh_token(config)
    access_token = refresh_token_model.issue_access_token(config)
    return UserAuthSchema(
        id=db_user.id,
        name=db_user.name,
        email=db_user.email,
        refresh_token=refresh_token,
        access_token=access_token,
        session_id=refresh_token_model.id,
    )


@router.post("/login", response_model=UserAuthSchema)
async def login(*, request: Request, config: Config = Depends(get_config), user: LoginUserSchema) -> UserAuthSchema:
    """Login endpoint.

    Used to login a user.

    Raises:
    - InvalidCredentialsException: If the username or password is incorrect.

    Returns:
    - UserAuthSchema: User authentication schema with JWT tokens.
    """
    # TODO: Add captcha
    # TODO: Add email notification about new login
    db = request.state.db

    # Get user
    db_user = await UserModel.get_by_name_or_email(db, user.name)

    # Verify password
    if not verify_password(user.password, db_user.password):
        raise InvalidCredentialsException(detail="Password is incorrect")

    # Return auth info
    refresh_token_model = await UserTokenModel.create_obj(db, db_user.id)
    refresh_token = refresh_token_model.issue_refresh_token(config)
    access_token = refresh_token_model.issue_access_token(config)
    return UserAuthSchema(
        id=db_user.id,
        name=db_user.name,
        email=db_user.email,
        refresh_token=refresh_token,
        access_token=access_token,
        session_id=refresh_token_model.id,
    )


@router.post("/simple_login", response_model=UserAuthSchema, deprecated=True)
async def simple_login(
    *, request: Request, config: Config = Depends(get_config), form_data: OAuth2PasswordRequestForm = Depends()
) -> UserAuthSchema:
    """Login without password hash.

    Used to login a user without password hashing.
    Must be used only for Swagger UI.

    Marked as deprecated to prevent use on the frontend.

    Raises:
    - InvalidCredentialsException: If the username is incorrect.

    Returns:
    - UserAuthSchema: User authentication schema with JWT tokens.
    """
    db = request.state.db

    # Construct user
    user = LoginUserSchema(name=form_data.username, password=form_data.password)
    # Get user
    db_user = await UserModel.get_by_name_or_email(db, user.name)
    # Hash password
    user.password = sha512(user.password.encode() + db_user.client_salt.encode()).hexdigest()
    # Proxy request to login endpoint
    return await login(request=request, config=config, user=user)


@router.post("/change_password", response_model=bool)
async def change_password(
    *, request: Request, config: Config = Depends(get_config), form: ChangeUserPasswordSchema
) -> bool:
    """Change password endpoint.

    Used to change a user's password. All other sessions will be revoked.

    Raises:
    - InvalidCredentialsException: If the old password is incorrect.

    Returns:
    - bool: True if password was changed.
    """
    # TODO: use authentication provider instead of custom schema field
    db = request.state.db

    # Get refresh token model
    token_model = await UserTokenModel.get_by_access_token(config, db, form.access_token)
    query = select(UserModel).filter_by(id=token_model.user_id)
    db_user: UserModel = (await db.execute(query)).scalars().first()
    if not db_user:
        raise InvalidCredentialsException(detail="User does not exist")

    # Verify password
    if not verify_password(form.old_password, db_user.password):
        raise InvalidCredentialsException(detail="Old password is incorrect")

    # Hash password
    hashed_password = get_password_hash(form.new_password)

    # Update password and salt
    db_user.password = hashed_password
    if form.client_salt is not None:
        db_user.client_salt = form.client_salt

    db.add(db_user)
    await db.commit()

    # Terminate all other sessions
    query = (
        select(UserTokenModel)
        .filter_by(user_id=db_user.id)
        .where(UserTokenModel.id != token_model.id)
        .where(UserTokenModel.revoked is False)
    )
    sessions: list[UserTokenModel] = (await db.execute(query)).scalars().all()
    for token in sessions:
        token.revoked = True
        db.add(token)

    await db.commit()

    return True


@router.post("/access_token", response_model=str)
async def refresh_access_token(
    request: Request, config: Config = Depends(get_config), refresh_token: str = Body()
) -> str:
    """Refresh access token endpoint.

    Used to refresh an access token.

    Raises:
    - InvalidCredentialsException: If the refresh token is invalid.

    Returns:
    - str: JWT access token.
    """
    db = request.state.db

    # Get refresh token model
    refresh_token_model: UserTokenModel = await UserTokenModel.get_by_refresh_token(config, db, refresh_token)

    # Generate access token
    return refresh_token_model.issue_access_token(config)


@router.get("/check_auth", response_model=PublicUserSchema)
async def check_auth(db_user: UserModel = Depends(get_current_user)) -> PublicUserSchema:
    """Check auth endpoint.

    Used to check if a user is authenticated.

    Raises:
    - InvalidCredentialsException: If the access token is invalid.

    Returns:
    - PublicUserSchema: User data.
    """
    return PublicUserSchema.from_orm(db_user)


@router.post("/reset_password", response_model=bool)
async def reset_password(
    email: str = Query(
        min_length=6,
        max_length=64,
        regex=r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)",
    )
) -> bool:
    """Reset password endpoint.

    **Not implemented yet.**

    Used to reset a user's forgotten password.

    Returns:
    - bool: True if password reset email was sent.
    """
    raise NotImplementedException()


@router.post("/remind_email", response_model=bool)
async def remind_email(
    name: str = Query(
        min_length=3,
        max_length=16,
        regex=r"^[a-zA-Z0-9_]+$",
    )
) -> bool:
    """Remind email endpoint.

    **Not implemented yet.**

    Used to remind a user's email.

    Returns:
    - bool: True if email to user was sent.
    """
    raise NotImplementedException()
